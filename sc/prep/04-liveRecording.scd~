( forkIfNeeded {
// The ~preRecorder is a prerec mechanism.  It continuously record in
// a two minute buffer.  When the ~recorder synth receives a trigger
// message, it replies its current recording position.  A preRecBuffer
// uses that position to copy a section of the ~preRecorder buffer
// into its own buffer.

//  By default, I create 5 ~preRecBuffers that old 4, 5, 7, 10 and 15
//  seconds of sound.  The same ~preRecorder is used for all
//  ~preRecBuffers.  Only one channel is assumed at this point.

~preRecorder = Proto({
	~sr = Server.default.sampleRate;
	~initialize = { |dur=120|
		forkIfNeeded {
			~dur = ~sr * dur; // Defaults to 2 minutes seconds at 48000.
			// Buffer to continuously record input.
			~buf = Buffer.alloc( Server.default, ~dur, 1);
			// FFT Buffer for onset detection.
			~fftBuf = Buffer.alloc(Server.default, 1024);
			SynthDef(\record, {
				arg in=0, buf=0, t_trig, id=0, fftBuf=500;
				var phasor, onsets, chain, input;
				input = SoundIn.ar(in);
				phasor = Phasor.ar(0, 1, 0, BufFrames.kr(buf));
				BufWr.ar(
					input,
					bufnum: buf,
					phase: phasor
				);
				// Onset detection: first, intense noise gating to
				// avoid false onsets from environmental noise.
				input = Compander.ar(input, input, -30.dbamp, 100, 1, 0.002);
				// Then actual onset detection.
				chain = FFT(fftBuf, input);
				onsets = Onsets.kr(chain, 0.7, \wphase);
				SendReply.kr(t_trig, "/buffer_pos", phasor, id);
				SendReply.kr(onsets, "/onset", phasor);
			}).add;
			
			Server.default.sync; //
			// Always recording, looping.
			~recorder = Synth.head(Server.default, \record, [
				\buf, ~buf,
				\fftBuf, ~fftBuf
			]);
		};
		currentEnvironment;
	};
	~free = {
		~recorder.free;
		~buf.free;
		~fftBuf.free;
	};
});

~preRecBuffer = Proto({
	~initialize = { |liveRecorder, dur=4, numChan=1|
		~sr = Server.default.sampleRate;
		~dur = dur; // default is 4 seconds.  This is decided at prep time.
		~frames = ~sr * ~dur;
		~numChan = numChan;
		~buf = Buffer.alloc(Server.default, ~frames, ~numChan);
		~liveRecBuf = liveRecorder.buf;
		~liveRecSynth = liveRecorder.recorder;
		~tmpOnsets = List[];
		~onsets = List[];
		~copyFunc = { |bufPos|
			~liveRecBuf.copyLoopTo(
				buf: ~buf,
				dstStartAt: 0,
				srcStartAt: (bufPos - ~frames),
				numSamples: ~frames
			);
			"Copying buffer ".post;
			~liveRecBuf.bufnum.post;
			" to buffer ".post;
			~buf.bufnum.postln;
			"Length: ".post;
			~dur.post;
			" seconds.".postln;
			~getBufferData.value();
			/// MVC: update the GUI if present. 
			currentEnvironment.changed(\bufferUpdated);
		};
		~oscFunc = OSCFunc({ |msg|
			var nodeID, bufnum, bufPos, startPos, first;
			#nodeID, bufnum, bufPos = msg[1..3];
			(bufnum == ~buf.bufnum and:	//make sure the message is for us.
				~liveRecSynth.nodeID == nodeID ).if ({ 
					~copyFunc.value(bufPos); // and copy.
					// Reposition onsets according to this ~buf
					startPos = (bufPos - ~frames) % ~liveRecBuf.numFrames;
					first = ~tmpOnsets.first;
					(startPos < bufPos).if ({ // normal situation;
						while {
							(first.notNil) and:
							((first <= startPos) or: (first > bufPos))
						}.try {
							~tmpOnsets.removeAt(0);
							first = ~tmpOnsets.first;
						};
					},{ // recording looped and start point is ahead of end.
						while {
							(first.notNil) and:
							((first > bufPos) and: (first <= startPos))
						}.try {
							~tmpOnsets.removeAt(0);
							first = ~tmpOnsets.first;
						};
					});
					~onsets = ((~tmpOnsets - startPos) % ~frames).sort;
					// "Onsets are at: ".post;
					// ~onsets.postln;
				});
		}.inEnvir, "/buffer_pos", Server.default.addr);
		~onsetOscFunc = OSCFunc({ |msg|
			var bufPos;
			bufPos = msg[3];
			// startPos = (bufPos - ~frames) % ~liveRecBuf.numFrames;
			~tmpOnsets.add(bufPos);
			// first = ~tmpOnsets.first;
			// (startPos < bufPos).if ({ // normal situation;
			// 	while { (first <= startPos) or: (first > bufPos) } {
			// 		~tmpOnsets.removeAt(0);
			// 		first = ~tmpOnsets.first;
			// 	};
			// },{ // recording looped and start point is ahead of end.
			// 	while { (first > bufPos) and: (first <= startPos) } {
			// 		~tmpOnsets.removeAt(0);
			// 		first = ~tmpOnsets.first;
			// 	};
			// });
			// "Temporary onsets: ".post;
			// ~tmpOnsets.postln;
			currentEnvironment.changed(\onsetDetected);
		}.inEnvir, "/onset", Server.default.addr);
		currentEnvironment;
	};
	~preRec = { // Prerecord the last ~dur seconds.
		// Tell ~liveRecSynth that we want to copy the
		// last ~dur recorded to our ~buf.
		// ID is the bufnum of ~buf so we know where to copy.
		~liveRecSynth.set(\id, ~buf.bufnum, \t_trig, 1.0);
	};
	~free = {
		~buf.free;
		~oscFunc.disable; // not "free"
		~onsetOscFunc.disable; // not "free"
	};
	~getBufferData = {
		forkIfNeeded {
			~buf.loadToFloatArray(0,-1, { |data|
				~bufferData = data;
			}.inEnvir);
			Server.default.sync;
			~bufferData;
		}
	};
	~makeGui = { | winPos |
		//
		topEnvironment[\preRecBufferGui].new(currentEnvironment, winPos);
	};
});

                  /////////////////////
                  // Fantastic Gui ! //
                  /////////////////////

~preRecBufferGui = Proto({
	~initialize = { |preRecBuffer, winPos|
		~prb = preRecBuffer;
		~prb.addDependant(currentEnvironment); // MVC
		winPos = winPos ? 700@700;
		{
			~window = Window(
				~prb.dur.asString ++ " second Buffer",
				Rect(winPos.x, winPos.y, 740, 100);
			);
			~window.layout = HLayout(
				~recButton = Button(~window),
				~sf = SoundFileView(~window),
				~onsetButton = Button(~window)
			);
			~sf.gridOn = false;
			~recButton.states_(
				[["PreRecord\n" ++ ~prb.dur.asString ++ " seconds" ]]
			);
			~onsetButton.states_(
				[["Onset\nIndicator"],["BOOM !!!",nil,Color.red]]
			);
			~recButton.action_({ ~prb.preRec }.inEnvir);
			~window.front;
			~updateBufferData.value();
			~window.onClose_({ // MVC
				~prb.removeDependant(currentEnvironment);
			}.inEnvir);
		}.inEnvir.defer;
		currentEnvironment;
	};

	~updateBufferData = {
		forkIfNeeded {
			~prb.getBufferData;
			Server.default.sync;
			{
				~sf.setData(~prb.bufferData, ~prb.sr);
				// Make a short selection at each onset.
				64.do({|id| // The max number of selections.
					~prb.onsets[id].notNil.if({
						\frame.post; ~prb.onsets[id].postln;
						~sf.setSelectionStart(id, ~prb.onsets[id]);
						~sf.setSelectionSize(id, 480);
						~sf.setEditableSelectionStart(id, false);
						~sf.setEditableSelectionSize(id, false);
						~sf.setSelectionColor(id, Color.grey(0.6));
					},{
						~sf.setSelectionSize(id, 0);
					});
				});
			}.inEnvir.defer;
		};
	};

	~updateOnsetButton = {
		{
			{
				~onsetButton.value_(1);
				0.3.wait;
				~onsetButton.value_(0);
			}.forkIfNeeded(AppClock);
		}.inEnvir.defer;
	};

	~update = { arg envir, what ... args;	// respond to a change in a model (MVC)
		forkIfNeeded {
			Server.default.sync;
			what.switch(
				\bufferUpdated,{ ~updateBufferData.value(); },
				\onsetDetected,{ ~updateOnsetButton.value(); }
			)
		}
	};
});


~lc = ~preRecorder.new(120);
Server.default.sync;
// make 5 preRecBuffers
// init them with 4, 5, 7, 10 and 15 second buffers
~recBufs = [4,5,7,10,15].collect({|i|
	~preRecBuffer.new(~lc, i, 1);
});
// And make a gui for this stuff.
~bufferData = Array.fill(~recBufs.size, { [] });

Server.default.sync;
}
);
~gui = ~recBufs[0].makeGui(700@700);

~gui.sf.selections;
~gui.sf.currentSelection_(1);
~gui.sf.setSelectionColor(0, Color.grey(0.7));
~gui.sf.gridOn = false;


[].first;